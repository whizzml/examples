;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Code to obtain association rules from:
;; https://github.com/mmerce/examples/blob/batch-assoc/batch-association-sets/

(define (describe-item item field-info)
  (let (complement? (item "complement" false)
        comp (if complement? "not " "")
        field-name (field-info "name")
        [start end] [(item "bin_start" false) (item "bin_end" false)]
        [start end] (if complement? [end start] [start end]))
    (if (item "name" false)
        (cond (and (numeric-field? field-info) start end)
                (if (< start end)
                    (str start " < " field-name " <= " end)
                    (str field-name " > " start " or <=" end))
              (and (numeric-field? field-info) start)
                (str field-name " > " start)
              (and (numeric-field? field-info) end)
                (str field-name " <= " end)
              (categorical-field? field-info)
                (str field-name " " (if complement? "!=" "=")
                     " " (item "name"))
              (or (text-field? field-info)
                  (items-field? field-info))
                (str field-name " " (if complement? "excludes" "includes")
                     " " (item "name")))
        (str field-name " is " comp "missing"))))

(define (flatline-item item field-info)
  (let (complement? (item "complement" false)
        field-name (field-info "name")
        [start end] [(item "bin_start" false) (item "bin_end" false)]
        [start end] (if complement? [end start] [start end]))
    (if (item "name" false)
        (cond (and (numeric-field? field-info) start end)
                (if (< start end)
                    (str "(and (< " start " (f \"" field-name
                         "\")) (<= (f \"" field-name "\") " end "))")
                    (str "(or (> (f \"" field-name "\") " start
                         ") (<= (f \"" field-name  "\") " end "))"))
              (and (numeric-field? field-info) start)
                (str "(> (f \"" field-name "\") " start ")")
              (and (numeric-field? field-info) end)
                (str "(<= (f \"" field-name "\") " end ")")
              (categorical-field? field-info)
                  (str "(" (if complement? "!=" "=") " (f \"" field-name
                       "\") \"" (item "name") "\")")
              (text-field? field-info)
                (let (op (if complement? "=" ">")
                      options (field-info "term_analysis")
                      case-s (options "case_sensitive" false)
                      case-i (if case-s "false" "true")
                      language (options "language"))
                  (str "(" op " (occurrences (f \"" field-name "\") \""
                      (item "name") "\" " case-i language ") 0)"))
              (items-field? field-info)
                (if complement?
                    (str "(not (contains-items? \"" field-name "\" \""
                       (item "name") "\"))")
                    (str "(contains-items? \"" field-name "\" \""
                       (item "name") "\")")))
        (if complement?
            (str "(not (missing? (f \"" field-name "\")))")
            (str "(missing? (f \"" field-name "\"))")))))

(define (describe-rule association rule-id match)
  (let (fields (resource-fields association)
        items (association ["associations" "items"] [])
        rules (association ["associations" "rules"] [])
        rule (try (head (filter (lambda (r) (= (r "id") rule-id)) rules))
               (catch e (log-error "The rule does not exist")))
        get-item-fn (lambda (i) (let (item (items i)
                                      field-info (fields (item "field_id")))
                                  (describe-item item field-info)))
        lhs (map get-item-fn (rule "lhs"))
        rhs (map get-item-fn (rule "rhs")))
    (cond (= match "antecedent")
            (join " and " lhs)
          (= match "consequent")
            (join " and " rhs)
            (str (join " and " lhs) " then " (join " and " rhs)))))

(define (flatline-rule association rule match)
  (let (fields (resource-fields association)
        items (association ["associations" "items"] [])
        get-item-fn (lambda (i)
                      (flatline-item (items i) (fields ((items i) "field_id"))))
        lhs (map get-item-fn (rule "lhs"))
        rhs (map get-item-fn (rule "rhs"))
        lhs (if (> (count lhs) 1)
                (str "(and " (join " " lhs) ")")
                (join " " lhs))
        rhs (if (> (count rhs) 1)
                (str "(and " (join " " rhs) ")")
                (join " " rhs)))
    (cond (= match "antecedent")
            lhs
          (= match "consequent")
            rhs
            (str "(and " lhs " " rhs ")"))))

(define (batch-association-sets dataset-id association-id dataset-name
         match . rule-ids)
  (let (association (fetch association-id)
        dataset-name (if (empty? dataset-name)
                         (str ((fetch dataset-id) "name") " with "
                              ((fetch association-id) "name"))
                         dataset-name)
        rule-ids (if (empty? (head rule-ids []))
                   (map (lambda (r) (r "id"))
                        (association ["associations" "rules"]))
                   (head rule-ids))
        rules (filter (lambda (r) (member? (r "id") rule-ids))
                      (association ["associations" "rules"]))
        flatline-rules (map (lambda (r) (flatline-rule association r match))
                            rules)
        new-fields (iterate (acc [] flatline-rule flatline-rules rule rules)
                     (append acc {"field" flatline-rule
                                  "name" (describe-rule association
                                                        (rule "id")
                                                        match)
                                  "label" (str (association "name")
                                               " - rule "
                                               (rule "id"))})))
    (when (empty? new-fields)
          (raise (str "No rules were found for the list of IDs: "
                      (join ", " rule-ids))))
    (create-dataset {"origin_dataset" dataset-id
                     "name" dataset-name
                     "new_fields" new-fields})))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; own code for the rest of unsupervised models ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (check-execution exec)
  (let (possible-types ["anomaly-id" "association-id" "cluster-id"
                        "pca-id" "topicmodel-id"]
        execution (fetch (wait exec))
        output-types (map (lambda (r) (head r))
                   (get-in execution ["execution" "outputs"])))
    (map (lambda (t) (or (member? t output-types)
                         (raise (str "Wrong execution outputs. "
                                     "Check unsupervised-gen-execution"))))
         possible-types)))

(define (get-exec-model-id exec model-type)
  (let (execution (fetch (wait exec))
        outputs (filter (lambda (r) (= (r 2) model-type))
                  (get-in execution ["execution" "outputs"])))
    (when (not (empty? outputs))
       ((head outputs) 1))))

(define (unsupervised-batch dataset-id model-id name batch-type)
  (log-info "Creating " batch-type)
  (let (params {"name" (str name " : " batch-type)
                "output_dataset" true})
    (try
     (create batch-type dataset-id  model-id params)
     (catch e
       (log-warn "Could not create the " batch-type ": " e)))))

(define (cluster-feature-gen ds-id exec name)
  (let (model-id (get-exec-model-id exec "cluster"))
    (when model-id
      (unsupervised-batch ds-id
                          model-id
                          name
                          "batchcentroid"))))

(define (anomaly-feature-gen ds-id exec name)
  (let (model-id (get-exec-model-id exec "anomaly"))
    (when model-id
      (unsupervised-batch ds-id
                          model-id
                          name
                          "batchanomalyscore"))))

(define (association-feature-gen ds-id exec name)
  (let (model-id (get-exec-model-id exec "association")
        full-name (str name "-association-rules"))
   (batch-association-sets dataset-id model-id full-name "antecedent")))

(define (topic-feature-gen ds-id exec name)
  (let (model-id (get-exec-model-id exec "topicmodel"))
    (when model-id
      (unsupervised-batch ds-id
                          model-id
                          name
                          "batchtopicdistribution"))))

(define (pca-feature-gen ds-id exec name)
  (let (model-id (get-exec-model-id exec "pca"))
    (when model-id
      (unsupervised-batch ds-id
                          model-id
                          name
                         "batchprojection"))))

(define (batch-output-ds res)
  (when res ((fetch (wait res)) "output_dataset_resource")))

(define (create-output-dataset ds-list name objective-id)
  (update
   (merge-datasets (filter (lambda (n) n) ds-list)
                   {"juxtapose" true
                    "name" (str name ": Extended dataset")})
   {"objective_field" {"id" objective-id}}))

(define (feature-generation dataset-id exec)
  (check-execution exec)
  (let (objective-id (dataset-get-objective-id dataset-id)
        name ((fetch (wait dataset-id)) "name")
        cluster-fields (cluster-feature-gen dataset-id exec name)
        anomaly-fields (anomaly-feature-gen dataset-id exec name)
        dataset-with-assoc-rules (association-feature-gen dataset-id exec name)
        topic-fields (topic-feature-gen dataset-id exec name)
        pca-fields (pca-feature-gen dataset-id exec name)
        all-fields [cluster-fields anomaly-fields topic-fields pca-fields]
        all-ds (cons dataset-with-assoc-rules
                     (map batch-output-ds all-fields)))
    (create-output-dataset all-ds name objective-id)))

(define extended-dataset
  (feature-generation dataset-id unsupervised-gen-execution))
